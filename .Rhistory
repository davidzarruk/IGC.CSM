#'
#' @param theta Float - Parameter that governs the reallocation of workers across
#'     locations in the city. This parameter measures how sensible are migration
#'     flows within the city to changes in real income.
#' @param alpha Float - Para
#' @param Q Nx1 matrix - Floor space prices.
#' @param L_i Nx1 matrix - Total residents.
#' @param W_i Nx1 matrix - Market access measure in each location.
#' @param t_ij NxN matrix - Travel times across locations.
#' @param rho Float - decay parameter for amenities.
#' @param eta Float - congestion force
#'
#' @return Matrix with the amenity distribution of living in each location.
#'
#' @examples
living_amenities_simple = function(theta,
N,
L_i,
W_i,
Q,
K,
alpha,
t_ij,
rho,
eta){
Q_mean = exp(mean(log(Q)));
Q_norm = Q/Q_mean;
L_i_mean = exp(mean(log(L_i)));
L_i_norm = L_i/L_i_mean;
W_i_mean = exp(mean(log(W_i)));
W_i_norm = W_i/W_i_mean;
B = array_operator(array_operator(L_i_norm^(1/theta), Q_norm^(1-alpha), '*'), W_i_norm^((-1)/theta), '*');
L_i_dens = (array_operator(L_i, K, '/'));
L_i_dens_per = aperm(array(L_i_dens, dim=c(N,1)), c(2,1));
L_i_dens_rep = kronecker(L_i_dens_per, array(1, dim=c(N, 1)));
Omega = sumDims2(array_operator(exp(-rho*t_ij), L_i_dens_rep, '*'), 2);
b = array_operator(B, Omega^(-eta), "/");
b = b*(L_i>0);
return(list(B = B, b = b))
}
#' Function to invert model, so amenities, wages, productivities, and development density
#'  are chosen to match model to data.
#'
#' @param N Integer - Number of locations.
#' @param t_ij NxN matrix - Travel times across all possible locations.
#' @param L_i Nx1 matrix - Number of residents in each location.
#' @param L_j Nx1 matrix - Number of workers in each location.
#' @param Q Nx1 matrix - Floorspace prices
#' @param K Nx1 matrix - Land area
#' @param tol Int - tolerance factor
#' @param maxiter Integer - Maximum number of iterations for convergence.
#'     Default maxiter=1000.
#' @param alpha Float - Utility parameter that determines preferences for
#'     consumption.
#' @param beta Float - Output elasticity wrt labor
#' @param theta Float - Commuting elasticity and migration elasticity.
#' @param lambda Float - Agglomeration force
#' @param delta Float - Decay parameter agglomeration
#' @param eta Float - Congestion force
#' @param rho Float - Decay parameter congestion
#' @param mu Float - Floorspace prod function: output elast wrt capital, 1-mu wrt land.
#'
#' @param zeta_intervals TODO
#' @param zeta_mult TODO
#'
#' @return Equilibrium values.
#' @export
#'
#' @examples
inversionModel = function(N,
L_i,
L_j,
Q,
K,
t_ij,
zeta,
z_init,
tol=10^-10,
maxiter=1000,
alpha,
beta,
theta,
delta,
rho,
lambda,
epsilon,
mu,
eta,
nu_init=0.005,
nu_intervals = c(),
nu_mult = c(),
zeta_intervals = c(),
zeta_mult = c()){
# Formatting of input data
L_i = array(unlist(L_i), dim(L_i))
L_j = array(unlist(L_j), dim(L_j))
K = array(unlist(K), dim(K))
Q = array(unlist(Q), dim(Q))
t_ij = array(unlist(t_ij), dim(t_ij))
# Initialization
w_init=array(1, dim=c(N,1))
# Transformation of travel times to trade costs
D = commuting_matrix(t_ij=t_ij,
epsilon=epsilon)
tau = D$tau
# Finding the wages that match the data
WI = wages_inversion(N=N,
w_init=w_init,
theta=theta,
tau=tau,
L_i=L_i,
L_j=L_j,
nu_init=nu_init,
tol=tol,
maxiter=maxiter,
nu_intervals = nu_intervals,
nu_mult = nu_mult)
# Equilibrium wages
w = WI$w
w_tr = WI$w_tr
W_i = WI$W_i
lambda_ij_i = WI$lambda_ij_i
# Average income
Inc = av_income_simple(lambda_ij_i=lambda_ij_i,
w_tr = w_tr
)
y_bar = Inc$y_bar
#Density of development
DensD = density_development(Q=Q,
K=K,
w=w,
L_j=L_j,
y_bar=y_bar,
L_i=L_i,
beta=beta,
alpha=alpha,
mu=mu
)
Q_mean = DensD$Q_mean
Q_norm = DensD$Q_norm
FS_f = DensD$FS_f
FS_r = DensD$FS_r
FS = DensD$FS
varphi = DensD$varphi
ttheta = FS_f/FS
#Productivities
Prod = productivity(N=N,
Q=Q,
w=w,
L_j=L_j,
K=K,
t_ij = t_ij,
delta=delta,
lambda=lambda,
beta=beta
)
A = Prod$A
a = Prod$a
# Amenities
AM = living_amenities_simple(theta=theta,
N=N,
L_i=L_i,
W_i=W_i,
Q=Q,
K=K,
alpha=alpha,
t_ij=t_ij,
rho=rho,
eta=eta
)
B = AM$B
b = AM$b
# Save and export
Q_alpha = Q_norm^(1-alpha)
u = array_operator(array_operator(W_i,Q_alpha,'/'),B,'*')
U = (sumDims(u,1))^(1/theta)
return(list(A=A, a=a, u=u, B=B, b=b, w=w, varphi=varphi, U=U, Q_norm=Q_norm, ttheta=ttheta))
}
#' Function to solve counterfactuals.
#'
#' @param N Integer - Number of locations.
#' @param L_i Nx1 array - Number of residents in each location
#' @param L_j Nx1 array - Number of workers in each location
#' @param t_ij NxN matrix - Travel times across locations
#' @param varphi Nx1 array - Density of development
#' @param K Nx1 array - Land supply
#' @param a Nx1 array - Total Factor Productivity in each location
#' @param b Nx1 array - Vector of amenities in each location
#' @param maxiter Integer - Maximum number of iterations for convergence.
#'     Default maxiter=1000.
#' @param alpha Float - Exp. share in consumption, 1-alpha exp. share in housing
#' @param beta Float - Output elasticity with respect to labor
#' @param theta Float - Commuting and migration elasticity.
#' @param mu Float - Floorspace prod function: output elasticity wrt capital
#' @param delta Float - Decay parameter agglomeration force
#' @param lambda Float - agglomeration externality
#' @param rho Float - decay parameter for amenities
#' @param eta Float - amenity externality
#' @param epsilon Float - Parameter that transforms travel times to commuting costs
#' @param w_eq Nx1 array - Initial vector of wages
#' @param u_eq Nx1 array - Initial vector of welfare
#' @param Q_eq Nx1 array - Initial price for floorspace
#' @param ttheta_eq Nx1 array - Share of floorspace used commercially
#' @param zeta Float - convergence parameter
#'
#' @return Counterfactual values.
#'
#' @examples
solveModel = function(N,
L_i,
L_j,
varphi,
t_ij,
K,
a,
b,
maxiter,
tol=10^-10,
alpha,
beta,
theta,
mu,
delta,
lambda,
rho,
eta,
epsilon,
w_eq,
u_eq,
Q_eq,
ttheta_eq
){
# Formatting of input data
D = commuting_matrix(t_ij=t_ij, epsilon = epsilon)
tau = D$tau
L_i = array(unlist(L_i),dim(L_i))
L_j = array(unlist(L_j),dim(L_j))
K = array(unlist(K), dim(K))
# Settings
outerdiff = Inf;
w = w_eq;
u = u_eq;
Q = Q_eq;
ttheta = ttheta_eq
iter = 0;
zeta_init = zeta;
while(outerdiff>tol & iter < maxiter){
print(iter)
# 1) Labor supply equation
w_tr = aperm(array(w, dim=c(N,1)), c(2,1));
rep_w_tr = kronecker(w_tr^theta, array(1, dim=c(N, 1)));
# Constructing employment shares
w_tr_tau = array_operator(w_tr^theta, tau^(-theta), '*');
lambda_ij_i = array_operator(w_tr_tau, sumDims2(w_tr_tau,2), '/');
W_i = (sumDims2(w_tr_tau,2))^(1/theta);
# Labor is equal to probabilities * total number of residents * proportion of workers in each sector.
L_ij = array_operator(L_i, lambda_ij_i, '*')
L_j = sumDims2(L_ij, 1)
L = sum(L_i)
lambda_i = L_i/L
# 2 average income
av_income = av_income_simple(lambda_ij_i=lambda_ij_i,w_tr = w_tr)
ybar = av_income$y_bar
# 3 Total floorspace
FS = array_operator(varphi,K^(1-mu),"*")
# 4 Agglomeration externalities
L_j_dens = (array_operator(L_j, K, '/'));
L_j_dens_per = aperm(array(L_j_dens, dim=c(N,1)), c(2,1));
L_j_dens_rep = kronecker(L_j_dens_per, array(1, dim=c(N, 1)));
Upsilon = sumDims2(array_operator(exp(-delta*t_ij), L_j_dens_rep, '*'), 2);
A = array_operator(a, Upsilon^lambda, '*')
# 5 Amenities
L_i_dens = (array_operator(L_i, K, '/'));
L_i_dens_per = aperm(array(L_i_dens, dim=c(N,1)), c(2,1));
L_i_dens_rep = kronecker(L_i_dens_per, array(1, dim=c(N, 1)));
Omega = sumDims2(array_operator(exp(-rho*t_ij), L_i_dens_rep, '*'), 2);
B = array_operator(b, Omega^(-eta),'*')
# 6 Residents, probabilities, and welfare
u =  array_operator(array_operator(W_i, Q^(1-alpha), '/'), B, '*')
U = sum(u^theta)
lambda_i_upd = (u^theta)/U
U = U^(1/theta)
# 7 Total output by location
FS_f = array_operator(ttheta,array_operator(varphi, K^(1-mu), '*'), '*')
Y = array_operator(A, array_operator(L_j^beta, FS_f^beta, '*'), '*')
Q_upd1 = (1-beta)*array_operator(Y,FS_f, '/')
w_upd = beta*array_operator(Y, L_j, '/')
# 8 Housing prices
FS_r = array_operator((1-ttheta), array_operator(varphi, K^(1-mu), '*'), '*')
X = array_operator(ybar, L_i, '*')
Q_upd2 = (1-alpha)*array_operator(X, FS_r, '/')
Q_upd = Q_upd1*(a>0) + Q_upd2*(a==0 & b>0)
# 9 Share of commercial floorspace
LP = array_operator(Q_upd1, array_operator(varphi, K^(1-mu), '*'), '*')
ttheta_upd = (1-beta)*array_operator(Y, LP, '/')
ttheta_upd = (b==0)+ttheta_upd*(b>0)
# 10 Calculating the main differences
z_w = array_operator(w, w_upd, '-')
z_L = array_operator(lambda_i, lambda_i_upd, '-')
z_Q = array_operator(Q, Q_upd, '-')
z_theta = array_operator(ttheta, ttheta_upd, '-')
outerdiff = max(c(max(abs(z_w)), max(abs(z_L)), max(abs(z_Q)), max(abs(z_theta))))
#outerdiff = max(c(max(abs(z_w)), max(abs(z_Q)), max(abs(z_theta))))
print(outerdiff)
iter = iter+1
# 11 New vector of variables
lambda_i = zeta*lambda_i + (1-zeta)*lambda_i_upd
Q = zeta*Q + (1-zeta)*Q_upd
w = zeta*w + (1-zeta)*w_upd
ttheta = zeta*ttheta + (1-zeta)*ttheta_upd
L_i = lambda_i*L
}
return(list(w=w, W_i=W_i, B=B, A=A, Q=Q, lambda_ij_i=lambda_ij_i, L_i=L_i, L_j=L_j,
ybar=ybar, lambda_i=lambda_i, ttheta=ttheta, u=u, U=U))
}
results_m_bl  = solveModel(N=N,
L_i=L_i,
L_j=L_j,
varphi=inversion_m_bl$varphi,
t_ij=t_ij,
K=K,
a=inversion_m_bl$a,
b=inversion_m_bl$b,
maxiter=10,
alpha=alpha1,
beta=beta0,
theta=theta1,
mu=mu0,
delta=delta0,
lambda=lambda,
rho=rho0,
eta=eta0,
epsilon=epsilon,
w_eq=inversion_m_bl$w,
u_eq=inversion_m_bl$u,
Q_eq=inversion_m_bl$Q_norm,
theta_eq=inversion_m_bl$ttheta)
results_m_bl  = solveModel(N=N,
L_i=L_i,
L_j=L_j,
varphi=inversion_m_bl$varphi,
t_ij=t_ij,
K=K,
a=inversion_m_bl$a,
b=inversion_m_bl$b,
maxiter=10,
alpha=alpha1,
beta=beta0,
theta=theta1,
mu=mu0,
delta=delta0,
lambda=lambda,
rho=rho0,
eta=eta0,
epsilon=epsilon,
w_eq=inversion_m_bl$w,
u_eq=inversion_m_bl$u,
Q_eq=inversion_m_bl$Q_norm,
ttheta_eq=inversion_m_bl$ttheta)
#' Array operator to mimic different-dimension-array element-wise operations in
#' MATLAB. It receives as input two arrays of potentially different dimensions,
#' it resizes them to have same dimensions and finally performs the element-wise
#' operation.
#'
#' @param array1 The first array
#' @param array2 The second array
#' @param operation The operation. It can take values: '+', '-', '*',
#' '/' and '^'
#'
#' @return An array with dimensions equal to the "largest" input array. It is
#' the result of applying the operator element-wise to both input arrays.
#'
#' @examples
array_operator = function(array1, array2, operation){
if(is.array(array1) == FALSE){
array1 = array(array1, dim=dim(array2))
} else if(is.array(array2) == FALSE){
array2 = array(array2, dim=dim(array1))
}
dim1 = dim(array1)
dim2 = dim(array2)
if(length(dim1) < length(dim2)){
array1 = kronecker(array1, array(1, dim = array(1, dim=length(dim2))))
dim1 = dim(array1)
} else if(length(dim1) > length(dim2)){
array2 = kronecker(array2, array(1, dim = array(1, dim=length(dim1))))
dim2 = dim(array2)
}
if(min(dim1-dim2) < 0){
array1_reshaped = kronecker(array1, array(1, dim=dim2-dim1+1))
array2_reshaped = array2
} else if(max(dim1-dim2) > 0){
array1_reshaped = array1
array2_reshaped = kronecker(array2, array(1, dim=dim1-dim2+1))
} else{
array1_reshaped = array1
array2_reshaped = array2
}
if(operation == '*'){
array_output = array1_reshaped*array2_reshaped
} else if(operation == '/'){
array_output = array1_reshaped/array2_reshaped
} else if(operation == '+'){
array_output = array1_reshaped+array2_reshaped
} else if(operation == '-'){
array_output = array1_reshaped-array2_reshaped
} else if(operation == '^'){
array_output = array1_reshaped^array2_reshaped
}
return(array_output)
}
#' Collapse array along one of the dimensions by adding the elements along that
#' dimension.
#'
#' @param array Array to collapse along one dimension.
#' @param dimension Dimension to collapse the array.
#'
#' @return An array that has been collapsed along the given dimension.
#'
#' @examples
sumDims = function(array, dimension){
dim1 = length(dim(array))
keep_dims = setdiff(seq(1, dim1, length.out = dim1), c(dimension))
array_output = apply(array, MARGIN = keep_dims, FUN = 'sum')
array_output = kronecker(array_output, array(1, dim=array(1, dim=dim1)))
dim_reshape = seq(1, dim1, length.out = dim1)
dim_reshape[(dimension+1):length(dim_reshape)] = dim_reshape[dimension:(length(dim_reshape)-1)]
dim_reshape[dimension] = dim1
array_output = aperm(array_output, dim_reshape);
return(array_output)
}
#' Collapse array 2 along one of the dimensions by adding the elements along that
#' dimension.
#'
#' @param array Array to collapse along one dimension.
#' @param dimension Dimension to collapse the array.
#'
#' @return An array that has been collapsed along the given dimension.
#'
#' @examples
sumDims2 = function(array, dimension){
dim1 = length(dim(array))
keep_dims = setdiff(seq(1, dim1, length.out = dim1), c(dimension))
array_output = apply(array, MARGIN = keep_dims, FUN = 'sum')
array_output = kronecker(array_output, array(1, dim=array(1, dim=dim1)))
return(array_output)
}
results_m_bl  = solveModel(N=N,
L_i=L_i,
L_j=L_j,
varphi=inversion_m_bl$varphi,
t_ij=t_ij,
K=K,
a=inversion_m_bl$a,
b=inversion_m_bl$b,
maxiter=10,
alpha=alpha1,
beta=beta0,
theta=theta1,
mu=mu0,
delta=delta0,
lambda=lambda,
rho=rho0,
eta=eta0,
epsilon=epsilon,
w_eq=inversion_m_bl$w,
u_eq=inversion_m_bl$u,
Q_eq=inversion_m_bl$Q_norm,
ttheta_eq=inversion_m_bl$ttheta)
results_m_bl  = solveModel(N=N,
L_i=L_i,
L_j=L_j,
varphi=inversion_m_bl$varphi,
t_ij=t_ij,
K=K,
a=inversion_m_bl$a,
b=inversion_m_bl$b,
maxiter=500,
alpha=alpha1,
beta=beta0,
theta=theta1,
mu=mu0,
delta=delta0,
lambda=lambda,
rho=rho0,
eta=eta0,
epsilon=epsilon,
w_eq=inversion_m_bl$w,
u_eq=inversion_m_bl$u,
Q_eq=inversion_m_bl$Q_norm,
ttheta_eq=inversion_m_bl$ttheta)
quantile(inversion_m_bl$a, p90 = c(.9))
quantile(inversion_m_bl$a, p90 = c(0.9))
quantile(inversion_m_bl$a, deciles = seq(.1, .9, by=0.1) )
quantile(inversion_m_bl$a, deciles = seq(.1, .9, by=0.1) )
quantile(a, deciles = seq(.1, .9, by=0.1) )
a = inversion_m_bl$a
quantile(a, deciles = seq(.1, .9, by=0.1) )
a = inversion_m_bl$a
quantile(a, p90 = 0.9)
p90
a = inversion_m_bl$a
p90=quantile(a, p90 = 0.9)
p90
quantile=quantile(a, 0.9)
quantile
a = inversion_m_bl$a
p90=quantile(a, 0.9)
a = inversion_m_bl$a
p90=quantile(a, 0.9)
a_new = a*(1+0.1*(a>p90))
a_new
