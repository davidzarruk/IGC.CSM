u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
zeta=zeta,
tol=tol,
maxiter=maxiter,
endo_Lr=endo_Lr,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
xi1=xi1,
sigma0=sigma0,
F=F);
zeta = 0.0001
# Solve model
results_m_bl  = solveModel1_Eff(N=N,
S=S,
L_bar=L_bar,
H_bar=H_bar,
H_bar_rest=H_bar_rest,
tau=tau,
A=inversion_m_bl$A,
u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
zeta=zeta,
tol=tol,
maxiter=maxiter,
endo_Lr=endo_Lr,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
xi1=xi1,
sigma0=sigma0,
F=F,
zeta_intervals = c(20, 100, 300, 500),
zeta_mult = c(500, 100, 50, 10));
zeta = 0.0001
# Solve model
results_m_bl  = solveModel1_Eff(N=N,
S=S,
L_bar=L_bar,
H_bar=H_bar,
H_bar_rest=H_bar_rest,
tau=tau,
A=inversion_m_bl$A,
u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
zeta=zeta,
tol=tol,
maxiter=maxiter,
endo_Lr=endo_Lr,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
xi1=xi1,
sigma0=sigma0,
F=F);
inversion_m_bl  = inversionModel_Eff(N=875,
S=3,
L_bar=1,
H_bar=read.csv("data/H_bar.csv"),
H_bar_rest=18,
tau=read.csv("data/tau.csv"),
lambda_i=read.csv("data/lambda_i.csv"),
lambda_is_i=read.csv("data/lambda_is_i.csv"),
L_j_data=read.csv("data/L_j_data.csv"),
zeta=0.1,
z_init=0.0001,
tol=10^-6,
maxiter=10,
alpha1=0.7,
beta0=0.7,
theta1=7,
eta1=1.5,
kappa1=2,
sigma0=6,
xi1=1.8,
nu_init=0.005,
F=1);
results_m_bl  = solveModel1_Eff(N=875,
S=3,
L_bar=1,
H_bar=read.csv("data/H_bar.csv"),
H_bar_rest=18,
tau=read.csv("data/tau.csv"),
A=inversion_m_bl$A,
u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=read.csv("data/lambda_i.csv"),
lambda_is_i=read.csv("data/lambda_is_i.csv"),
zeta=0.0001,
tol=1e-10,
maxiter=10,
endo_Lr=1,
alpha1=0.7,
beta0=0.7,
theta1=7,
eta1=1.5,
kappa1=2,
xi1=1.8,
sigma0=6,
F=1);
N=875
S=3
L_bar=1
H_bar=read.csv("data/H_bar.csv")
H_bar_rest=18
tau=read.csv("data/tau.csv")
A=inversion_m_bl$A
u_eq=inversion_m_bl$u
B=inversion_m_bl$B
w_eq=inversion_m_bl$w
lambda_i=read.csv("data/lambda_i.csv")
lambda_is_i=read.csv("data/lambda_is_i.csv")
zeta=0.0001
tol=1e-10
maxiter=10
endo_Lr=1
alpha1=0.7
beta0=0.7
theta1=7
eta1=1.5
kappa1=2
xi1=1.8
sigma0=6
F=1
# Formatting of input data
tau = array(unlist(tau), dim(tau))
H_bar = array(unlist(H_bar), dim(H_bar))
lambda_is_i = array(unlist(lambda_is_i), dim(lambda_is_i))
lambda_i = array(unlist(lambda_i), dim(lambda_i))
# Parameters
beta1 = beta0*array(1, dim=c(1,1,S))
sigma1 = sigma0*array(1, dim=c(1,1,S))
# Settings
outerdiff = Inf;
w = w_eq;
u = u_eq;
iter = 0;
zeta_init = zeta;
w_tr = aperm(array(w, dim=c(N,S,1)), c(3,1,2))
reptau = kronecker(tau, array(1, dim=c(1, 1, S)))
w_tr_reptau = array_operator(w_tr^theta1, reptau^(-theta1), '*')
lambda_ijs_is = array_operator(w_tr_reptau, sumDims(w_tr_reptau, 2), '/')
W_is_aux_1 = sumDims(w_tr_reptau,2);
W_is_aux = W_is_aux_1^(1/theta1);
W_is = aperm(W_is_aux, c(1,3,2));
B_W_is = array_operator(B, W_is, '*')^(kappa1)
lambda_is_i = array_operator(B_W_is, sumDims(B_W_is,2), '/');
lambda_is_i_p = aperm(kronecker(lambda_is_i, array(1, dim=c(1,1,1))), c(1, 3, 2));
l_prod = array_operator(lambda_i, array_operator(lambda_is_i_p, lambda_ijs_is, '*'), '*')
L_j_p = sumDims(l_prod, 1)
L_j = aperm(L_j_p, c(2, 3, 1));
# 2) Average income in each location
av_inc = av_income(lambda_is_i=lambda_is_i,
B=B,
W_is=W_is,
kappa1=kappa1,
lambda_ijs_is=lambda_ijs_is,
L_bar=L_bar,
w=w,
lambda_i=lambda_i);
L_j_eff=av_inc$L_j_eff
y_bar=av_inc$y_bar
# 3) Floorspace supply
floorspace = floorspace_supply(alpha1, H_bar_rest, H_bar, w, L_j_eff, y_bar, lambda_i, L_bar, beta1)
H_r = floorspace$H_r
H_f = floorspace$H_f
beta_tilde_sector = floorspace$beta_tilde_sector
q = floorspace$q
r = floorspace$r
# 5) Number of firms by location
num_firms = number_firms(N, beta1, beta_tilde_sector, w, L_j_eff, sigma1, q, F)
beta_factor=num_firms$beta_factor
M=num_firms$M
sigma_cons=num_firms$sigma_cons
H_f_sector = array_operator(array_operator(kronecker(beta_tilde_sector, array(1, dim=c(N,1,1))), sumDims(array_operator(w, L_j_eff, '*'),2), '*'), q, '/');
Q_js = array_operator(array_operator(L_j_eff, beta_factor, '^'), array_operator(H_f_sector, 1-beta_factor, '^'), '*');
elast_demand = aperm(array_operator(sigma1, sigma1-1, '/'), c(1,3,2));
inv_elast_demand = aperm(array_operator(sigma1-1, sigma1, '/'), c(1,3,2));
Q_s = array_operator(sumDims(array_operator(Q_js, elast_demand, '^'), 1), inv_elast_demand, '^');
Q = array_operator(sumDims(array_operator(Q_s, (xi1-1)/xi1, '^'),2), xi1/(xi1-1), '^');
# 6) Price in each location
price_loc = price_location(N, sigma1, beta_factor, w, q, A)
p_j = price_loc$p_j
inv_sigma = price_loc$inv_sigma
# 7) Aggregate price index and expenditure share in the variety of each location
agg_price_ind = agg_price_index(sigma1, xi1, M, p_j, sigma1_tr, inv_sigma)
pi_js = agg_price_ind$pi_js
pi_s = agg_price_ind$pi_s
P = agg_price_ind$P
# 8) Total sales in each location
total_sal = total_sales(N, y_bar, lambda_i, L_bar, r, H_r, q, H_f, alpha1, pi_js, pi_s)
Y_js = total_sal$Y_js
# 9) New labor demand and wages
new_labor_dem = new_labor_demand(sigma_cons, w, L_j_eff, beta_factor, Y_js, A, inv_sigma)
LD = new_labor_dem$LD
w_prime = array_operator(LD, L_j_eff, '/');
w_prime = array_operator(w_prime, w_prime[1,1,1], '/');
w_prime
w_prime[1:3,1:3]
w_prime[1:3,1:3,1]
q[1:3,1:3,1]
q[1:3,1:3]
q
q[1:3]
P
p_j[1:3,1:3,1]
M[1:3,1:3]
M[1:3,1:3,1]
Q_js[1:3,1:3,1]
Q
markup
w[1:3,1:3,1]
A[1:3,1:3,1]
inversion_m_bl$A[1:3,1:3,1]
inversion_m_bl$u[1:3,1:3,1]
inversion_m_bl$u
inversion_m_bl$u[1:3]
inversion_m_bl.B[1:3,1:3,1]
inversion_m_bl$B[1:3,1:3,1]
inversion_m_bl$w[1:3,1:3,1]
library(roxygen2)
setwd('/home/david/Documents/IGCities/')
rm(list = ls())
roxygenise()
#-----------------#
#   Parameters    #
#-----------------#
N = 875
S = 3
# Parameters
alpha1 = 0.7
theta1 = 7
eta1 = 1.5
kappa1 = 2
xi1 = 1.8
nu_init = 0.005
# Number of firms
beta0 = 0.7
F = 1
sigma0 = 6
# Basic Settings
tol = 1e-6
maxiter=10
zeta = 0.0001
endo_Lr = 1
z_init=10^-4
# Test trade costs
theta1=7
# Travel time
speed = 10
# Iceberg commuting cost
lambda = 0.01
# Workers and population
L_bar  = 1
H_bar_rest = 18
# Loaded parameters
H_bar = read.csv("data/H_bar.csv")
tau = read.csv("data/tau.csv")
L_j_data = read.csv("data/L_j_data.csv")
lambda_is_i = read.csv("data/lambda_is_i.csv")
lambda_i = read.csv("data/lambda_i.csv")
#----------------------------#
#      (2) Solve Models      #
#----------------------------#
inversion_m_bl  = inversionModel_Eff(N=875,
S=3,
L_bar=1,
H_bar=read.csv("data/H_bar.csv"),
H_bar_rest=18,
tau=read.csv("data/tau.csv"),
lambda_i=read.csv("data/lambda_i.csv"),
lambda_is_i=read.csv("data/lambda_is_i.csv"),
L_j_data=read.csv("data/L_j_data.csv"),
zeta=0.1,
z_init=0.0001,
tol=10^-6,
maxiter=10,
alpha1=0.7,
beta0=0.7,
theta1=7,
eta1=1.5,
kappa1=2,
sigma0=6,
xi1=1.8,
nu_init=0.005,
F=1);
# Solve model
results_m_bl  = solveModel1_Eff(N=875,
S=3,
L_bar=1,
H_bar=read.csv("data/H_bar.csv"),
H_bar_rest=18,
tau=read.csv("data/tau.csv"),
A=inversion_m_bl$A,
u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=read.csv("data/lambda_i.csv"),
lambda_is_i=read.csv("data/lambda_is_i.csv"),
zeta=0.0001,
tol=1e-10,
maxiter=10,
endo_Lr=1,
alpha1=0.7,
beta0=0.7,
theta1=7,
eta1=1.5,
kappa1=2,
xi1=1.8,
sigma0=6,
F=1);
library(roxygen2)
setwd('/home/david/Documents/IGCities/')
rm(list = ls())
roxygenise()
#-----------------#
#   Parameters    #
#-----------------#
N = 875
S = 3
# Parameters
alpha1 = 0.7
theta1 = 7
eta1 = 1.5
kappa1 = 2
xi1 = 1.8
nu_init = 0.005
# Number of firms
beta0 = 0.7
F = 1
sigma0 = 6
# Basic Settings
tol = 1e-6
maxiter=10
zeta = 0.0001
endo_Lr = 1
z_init=10^-4
# Test trade costs
theta1=7
# Travel time
speed = 10
# Iceberg commuting cost
lambda = 0.01
# Workers and population
L_bar  = 1
H_bar_rest = 18
# Loaded parameters
H_bar = read.csv("data/H_bar.csv")
tau = read.csv("data/tau.csv")
L_j_data = read.csv("data/L_j_data.csv")
lambda_is_i = read.csv("data/lambda_is_i.csv")
lambda_i = read.csv("data/lambda_i.csv")
zeta = 0.1
# Invert model
inversion_m_bl  = inversionModel_Eff(N=N,
S=S,
L_bar=L_bar,
H_bar=H_bar,
H_bar_rest=H_bar_rest,
tau=tau,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
L_j_data=L_j_data,
zeta=zeta,
z_init=z_init,
tol=tol,
maxiter=maxiter,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
sigma0=sigma0,
xi1=xi1,
F=F);
zeta = 0.0001
# Solve model
results_m_bl  = solveModel1_Eff(N=N,
S=S,
L_bar=L_bar,
H_bar=H_bar,
H_bar_rest=H_bar_rest,
tau=tau,
A=inversion_m_bl$A,
u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
zeta=zeta,
tol=tol,
maxiter=maxiter,
endo_Lr=endo_Lr,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
xi1=xi1,
sigma0=sigma0,
F=F);
?labor_productivity
install.packages('devtools')
library('devtools')
install_github("davidzarruk/IGCities");
N = 875
S = 3
# Parameters
alpha1 = 0.7
theta1 = 7
eta1 = 1.5
kappa1 = 2
xi1 = 1.8
nu_init = 0.005
# Number of firms
beta0 = 0.7
F = 1
sigma0 = 6
# Basic Settings
tol = 1e-6
maxiter=10
zeta = 0.0001
endo_Lr = 1
z_init=10^-4
# Test trade costs
theta1=7
# Travel time
speed = 10
# Iceberg commuting cost
lambda = 0.01
# Workers and population
L_bar  = 1
H_bar_rest = 18
# Loaded parameters
H_bar = read.csv("data/H_bar.csv")
tau = read.csv("data/tau.csv")
L_j_data = read.csv("data/L_j_data.csv")
lambda_is_i = read.csv("data/lambda_is_i.csv")
lambda_i = read.csv("data/lambda_i.csv")
#----------------------------#
#      (2) Solve Models      #
#----------------------------#
zeta = 0.1
# Invert model
inversion_m_bl  = inversionModel_Eff(N=N,
S=S,
L_bar=L_bar,
H_bar=H_bar,
H_bar_rest=H_bar_rest,
tau=tau,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
L_j_data=L_j_data,
zeta=zeta,
z_init=z_init,
tol=tol,
maxiter=maxiter,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
sigma0=sigma0,
xi1=xi1,
F=F);
zeta = 0.0001
# Solve model
results_m_bl  = solveModel1_Eff(N=N,
S=S,
L_bar=L_bar,
H_bar=H_bar,
H_bar_rest=H_bar_rest,
tau=tau,
A=inversion_m_bl$A,
u_eq=inversion_m_bl$u,
B=inversion_m_bl$B,
w_eq=inversion_m_bl$w,
lambda_i=lambda_i,
lambda_is_i=lambda_is_i,
zeta=zeta,
tol=tol,
maxiter=maxiter,
endo_Lr=endo_Lr,
alpha1=alpha1,
beta0=beta0,
theta1=theta1,
eta1=eta1,
kappa1=kappa1,
xi1=xi1,
sigma0=sigma0,
F=F)
source("~/Documents/IGCities/main_test.R", echo=TRUE)
library('IGCities')
source("~/Documents/IGCities/main_test.R", echo=TRUE)
source("~/Documents/IGCities/main_test.R", echo=TRUE)
